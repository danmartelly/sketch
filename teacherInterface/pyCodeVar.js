criteriaCode = {"MonotonicCriteria": "class MonotonicCriteria(Criteria):\n    title = \"Monotonicity Test Criteria\"\n    failMessage = \'Not monotonic\'\n    args = Criteria.args + [InputArg(\'domain\', \"Domain\", \"What range of x values this criteria will be checked on\", InputArg.DOMAIN,[-float(\'inf\'), float(\'inf\')]),\n                            InputArg(\'trend\', \"Trend\", \"1 means monotonically increasing, -1 means decreasing, 0 means either way\", InputArg.INTEGER, 0, True),\n                            InputArg(\'pixelCloseness\', \"Error margin (pixels)\", \"How far away in the wrong direction the student can go\", InputArg.INTEGER, 10)]\n    \"\"\"Check that data is monotonic. Can also specify whether a positive or\n   negative trend is there\"\"\"\n    def __init__(self, kwargs):\n        \"\"\" trend = -1 --> must be negative trend\n        trend = 0 --> doesn\'t matter if it\'s positive/negative, as long as its monotonic\n        trend = 1 --> must be positive trend\"\"\"\n        Criteria.__init__(self, kwargs)\n\n    def grade(self, graphData):\n        mini, maxi = self.domain\n        if mini < graphData.xmin: mini = graphData.xmin\n        if maxi > graphData.xmax: maxi = graphData.xmax\n        pixelMin = graphData.indexFromXY(mini, 5)[0]\n        pixelMax = graphData.indexFromXY(maxi, 5)[0]\n        if self.trend == 1 or self.trend == -1:\n            windowSize = 40\n            diffs = [p for p in graphData.getPixelDiff() if p.x > pixelMin and p.x < pixelMax]\n            vals = [p for p in graphData.getFunctionList() if p.x > mini and p.x < maxi]\n            if len(diffs) < windowSize:\n                if self.trend*sum([p.y for p in diffs]) < 0:\n                    return (0., self.failMessage + \'1\')\n                else:\n                    return (1., None)\n            else:\n                windowSum = sum([p.y for p in diffs[:windowSize]])\n                maxPixelDiff = 5\n                for i in range(windowSize, len(diffs)):\n                    windowSum -= diffs[i-windowSize].y\n                    windowSum += diffs[i].y\n                    if -self.trend*windowSum < -maxPixelDiff:\n                        return (0., self.failMessage + \'2 \' + str(self.trend) + str(windowSum))\n                biggest = -float(\'inf\')\n                for p in vals:\n                    if self.trend*p.y > biggest:\n                        biggest = self.trend*p.y\n                    else:\n                        diff = biggest - self.trend*p.y\n                        pixelDistance = graphData.indexFromXY(0,diff)[1] - graphData.indexFromXY(0,0)[1]\n                        if pixelDistance > self.pixelCloseness:\n                            return (0., self.failMessage + \'3 \' + str(self.trend)  + str(pixelDistance) + \' \' + str(biggest) )\n                return (1., None)\n        else:\n            self.trend = 1\n            score1 = self.grade(graphData)\n            self.trend = -1\n            score2 = self.grade(graphData)\n            self.trend = 0\n            score = max(score1,score2,key=lambda x:x[0])\n            return score\n    def updatePossibleScores(self, stroke, state, possibleDict, otherVars):\n        (xmin, xmax, ymin, ymax, pixelWidth, pixelHeight) = self.unpackOtherVars(otherVars)\n        prevj = pixelHeight\n        if len(stroke) > 0:\n            prevj = stroke[-1][1]\n        prevy = ymax - prevj*(ymax-ymin)/pixelHeight\n        if state == None: state = prevj\n        elif trend == 1: state = min(state, prevj)\n        elif trend == -1: state = max(state, prevj)\n        for (i, j) in possibleDict:\n            x = xmin + i*(xmax-xmin)/pixelWidth\n            y = ymax - j*(ymax-ymin)/pixelHeight\n            if x < self.domain[0] or x > self.domain[1]:\n                possibleDict[(i,j)] += self.weight\n            elif self.trend == 1:\n                multiplier = max(min(1 + float(state-j)/self.pixelCloseness, 1), 0)\n                possibleDict[(i,j)] += self.weight*multiplier\n            elif self.trend == -1:\n                multiplier = max(min(1 + float(j-state)/self.pixelCloseness, 1), 0)\n                possibleDict[(i,j)] += self.weight*multiplier\n\n            # TODO: deal with trend = 0\n    def isRelationshipPresent(self, otherVars):\n        return True\n    def relationshipRange(self, otherVars):\n        return self.domain\n    def relationshipIcon(self, otherVars):\n        if self.trend == 1:\n            return \"up.jpg\"\n        elif self.trend == -1:\n            return \"down.jpg\"\n        else:\n            return \"updown.jpg\"\n",
"PointsCriteria": "class PointsCriteria(Criteria):\n    title = \"Critical Point Check\"\n    args = Criteria.args + [InputArg(\'pixelCloseness\', \"Precision (pixels)\", \"How close the drawing has to get to the specified point to get full credit\", InputArg.INTEGER, 10),\n                            InputArg(\'list\', \"Points\", \"\", InputArg.MULTIPLEPOINTS,[],True)]\n    failMessage = \'Some critical points were missed\'\n    \'\'\'Check that the drawn graph contains this critical point within some range\n    Required arguments: *list: which is a list of 2 length tuples containing (x,y)\'\'\'\n    def __init__(self, kwargs):\n        self.pointList = kwargs[\'list\']\n        kwargs[\'list\'] = None\n        if type(self.pointList) != type([]) and type(self.pointList) != type((0,)):\n            self.pointList = eval(self.pointList)\n\n        Criteria.__init__(self, kwargs)\n    def grade(self, graphData):\n        self.pList = []\n        for p in self.pointList:\n            self.pList.append(util.Point(p[0],p[1]))\n        copyList = self.pList[:]\n        for p1Indices in graphData.blackPixels:\n            for i in range(len(copyList)-1,-1,-1):\n                p2Indices = graphData.indexFromXY(copyList[i].x, copyList[i].y)\n                if p1Indices.close(p2Indices, self.pixelCloseness):\n                    copyList.pop(i)\n                    continue\n            if len(copyList) == 0: break\n        if len(copyList) == 0:\n            return (1., None)\n        else:\n            return (0., self.failMessage + str(copyList) + \'missed\')\n    def getCriticalPoints(self, otherVars):\n        ans = []\n        for p in self.pointList:\n            ans.append({\'x\':p[0], \'y\':p[1], \'pixelRadius\':self.pixelCloseness})\n        return ans\n",
"InputArg": "class InputArg():\n    INTEGER = 0\n    FLOAT = 1\n    BOOL = 2\n    STRING = 3\n    LIST = 4\n    CODE = 5\n    FUNCTION = 6\n    SHAPE = 7\n    DOMAIN = 8\n    POINT = 9\n    MULTIPLEPOINTS = 10\n    mapping = {INTEGER:('integer',int),\n        FLOAT:('float',float),\n        STRING:('string',str),\n        LIST:('list',list),\n        CODE:('code',lambda x:x),\n        BOOL:('boolean',bool),\n        FUNCTION:('function',lambda x:x),\n        SHAPE:('shape', lambda x:x),\n        DOMAIN:('domain', lambda x:x),\n        POINT:('point', lambda x:x),\n        MULTIPLEPOINTS:('multiplePoints', lambda x:x)\n    }\n    def __init__(self, name, displayName, helpText, inputType, default, required=False):\n        self.name = name\n        self.displayName = displayName\n        self.helpText = helpText\n        self.inputType = inputType\n        self.default = default\n        self.required = required\n    def getDict(self):\n        d = {}\n        d['name'] = self.name\n        d['displayName'] = self.displayName\n        d['helpText'] = self.helpText\n        d['default'] = self.default\n        d['type'] = InputArg.mapping[self.inputType][0] \n        d['required'] = self.required\n        return d\n    def processInput(self, val):\n        return InputArg.mapping[self.inputType][1](val)\n",
"DerivativeCriteria": "class DerivativeCriteria(Criteria):\n    title = \"Derivative Check\"\n    args = Criteria.args + [InputArg(\'domain\', \"Domain\", \"For what x values you want to apply the criteria\", InputArg.DOMAIN, [-float(\'inf\'), float(\'inf\')]),\n                            InputArg(\'fraction\', \"Fraction Good\", \"What fraction of points drawn need to be inside the appropriate region\", InputArg.FLOAT,.8),\n                            InputArg(\'fprime\', \"Function of slope\", \"A function of the slope specified in terms of x specified with valid python syntax\", InputArg.FUNCTION, \"\", True),\n                            InputArg(\'angleCloseness\', \"Angle margin (degrees)\", \"How close the angle of the drawn slope has to be to the correct one\", InputArg.FLOAT, 20)]\n\n    failMessage = \'The slope of your graph doesn\\\'t match the answer\'\n    \'\'\'Check that the derivative graph has an appropriate derivative at the given x values\n    Required arguments: *list: which is a list of 2 length tuples containing (x, dy/dx)\'\'\'\n    def __init__(self, kwargs):\n        \"\"\"f should take in one paramater, x, and output y\"\"\"\n        f = kwargs[\'fprime\']\n        if type(f) != type(lambda x: x):\n            f = eval(\"lambda x: \" + f)\n        kwargs[\'fprime\'] = f\n        Criteria.__init__(self, kwargs)\n        \n    def grade(self, graphData):\n        derivList = graphData.getSmoothDerivList() \n        successes = 0\n        for p in derivList:\n            drawnAngle = math.atan(p.y)\n            corrAngle = math.atan(fprime(p.x))\n            diffAngle = abs(drawnAngle-corrAngle)\n            if diffAngle > math.pi/2:\n               diffAngle -= math.pi\n            if abs(diffAngle) < self.angleCloseness:\n                successes += 1\n        if float(successes)/len(derivList) > self.fraction:\n            return (1., None)\n        else:\n            return (float(successes)/len(self.pList), self.failMessage) \n\n    def getSlopes(self, otherVars):\n        horizontalDist = 40\n        verticalDist = 40\n\n        (xmin, xmax, ymin, ymax, pixelWidth, pixelHeight) = self.unpackOtherVars(otherVars)\n        mini, maxi = self.domain\n        if mini < xmin: mini = xmin\n        if maxi > xmax: maxi = xmax\n        imin = int(max(0, (self.domain[0] - xmin)/float(xmax-xmin)*pixelWidth))\n        imax = int(min(pixelWidth, (self.domain[1] - xmin)/float(xmax-xmin)*pixelWidth))\n\n        deg2rad = 3.14159/180\n        drawList = []\n        for i in range(imin, imax+1, horizontalDist):\n            x = xmin + i*(xmax-xmin)/pixelWidth\n            slope = self.fprime(x)\n            for j in range(80, pixelHeight, verticalDist):\n                y = ymax - (float(j)/pixelHeight)*(ymax-ymin)\n                drawList.append({\'x\':x, \'y\':y, \'slope\':slope, \'angleError\':self.angleCloseness*deg2rad})\n        return drawList\n",
"Criteria": "class Criteria():\n    title = \"Base Criteria Class Title (Update title variable)\"\n    helpText = \"\"\n    args = [InputArg(\'weight\', \"Grade Weight: \", \"What weight will this criteria have relative to others\", InputArg.FLOAT, 1), \n            InputArg(\'failFast\', \"Fail Immediately: \", \"When True, a student who does not pass this criteria instantly gets 0% as a grade\", InputArg.BOOL, False)]\n    failMessage = \'Criteria failed in some way\'\n    def __init__(self, kwargs):\n        missingArgs = []\n        unusedArgs = []\n        for inp in self.args:\n            if inp.name in kwargs:\n                setattr(self, inp.name, inp.processInput(kwargs.pop(inp.name)))\n            elif inp.required:\n                missingArgs.append(inp.name)\n            else:\n                setattr(self, inp.name, inp.default)\n        for k in kwargs:\n            unusedArgs.append(k)\n        error = \"\"\n        if len(missingArgs) > 0:\n            error += \'Missing arguments: \' + str(missingArgs) + \"\\n\"\n        if len(unusedArgs) > 0:\n            error += \"Extra unused arguments: \" + str(unusedArgs) + \"\\n\"\n        if error != \"\":\n            raise Exception(str(self.__class__) + error)\n    # returns grade performance between 0 and 1, and feedback string\n    # e.g. .5 means 50%, (.5, \'not all critical points hit\')\n    def grade(self, graphData):\n        raise NotImplementedError\n    # otherVars is a dictionary containing xmin, xmax, ymin, ymax, pixelWidth, pixelHeight\n    def unpackOtherVars(self, otherVars):\n        xmin = otherVars[\'xmin\']\n        xmax = otherVars[\'xmax\']\n        ymin = otherVars[\'ymin\']\n        ymax = otherVars[\'ymax\']\n        pixelWidth = otherVars[\'pixelWidth\']\n        pixelHeight = otherVars[\'pixelHeight\']\n        return (xmin, xmax, ymin, ymax, int(pixelWidth), int(pixelHeight))\n    def filteredList(self, otherVars, boolFuncXY):\n        (xmin, xmax, ymin, ymax, pixelWidth, pixelHeight) = self.unpackOtherVars(otherVars)\n        answer = []\n        for i in range(pixelWidth):\n            x = xmin + i*(xmax-xmin)/pixelWidth\n            for j in range(pixelHeight):\n                y = ymax - j*(ymax-ymin)/pixelHeight\n                if boolFuncXY(x,y):\n                    answer.append((i,j))\n        return answer\n    def updatePossibleScores(self,stroke, state, possibleDict, otherVars):\n        pass\n    def requiredPolygons(self, otherVars):\n        return None\n    def forbiddenPolygons(self, otherVars):\n        return None\n    def requiredList(self, otherVars):\n        # suggestion: make use of filteredList for other code\n        return []\n    def forbiddenList(self,otherVars):\n        # suggestion: make use of filteredList for other code\n        return []\n    def isRelationshipPresent(self, otherVars):\n        return False\n    def relationshipRange(self, otherVars):\n        return [0,0]\n    def relationshipIcon(self, otherVars):\n        return None\n    # list of {\'x\':1, \'y\':2, \'pixelRadius\':5}\n    def getCriticalPoints(self, otherVars):\n        return []\n    # list of {\'x\':1, \'y\':2, \'slope\':1, \'angleError\':20} (angleError in degrees)\n    def getSlopes(self, otherVars):\n        return []\n",
"FunctionFollowedCriteria": "class FunctionFollowedCriteria(Criteria):\n    title = \"Stick to Function Check\"\n    args = Criteria.args + [InputArg(\'domain\', \"Domain\", \"For what x values you want to apply the criteria\", InputArg.DOMAIN,[-float(\'inf\'), float(\'inf\')]),\n                            InputArg(\'fraction\', \"Fraction Good\", \"What fraction of points drawn need to be inside the appropriate region\", InputArg.FLOAT,.8),\n                            InputArg(\'f\', \"Function\", \"A function in terms of x specified with valid Python syntax\", InputArg.FUNCTION, \"\", True),\n                            InputArg(\'pixelCloseness\', \"Error margin (pixels):\", \"How close the drawing has to be to the correct answer\", InputArg.INTEGER, 10)]\n\n    failMessage = \'Did not match our function\'\n    \"\"\"Check if graph follows function through domain specified\n    Required arguments: f\"\"\"\n    def __init__(self, kwargs):\n        \"\"\"f should take in one paramater, x, and output y\"\"\"\n        f = kwargs[\'f\']\n        if type(f) != type(lambda x: x):\n            f = eval(\"lambda x: \" + f)\n        kwargs[\'f\'] = f\n        self.pixelCloseness = 40\n        self.domain = (-float(\'inf\'), float(\'inf\'))\n        self.fraction = .9\n        Criteria.__init__(self, kwargs)\n\n    #maximum added score of 1\n    def updatePossibleScores(self,stroke, state, possibleDict, otherVars):\n        (xmin, xmax, ymin, ymax, pixelWidth, pixelHeight) = self.unpackOtherVars(otherVars)\n        yCloseness = float(self.pixelCloseness)/(otherVars[\'pixelHeight\']/(otherVars[\'ymax\'] - otherVars[\'ymin\']))\n        for (i,j) in possibleDict:\n            x = xmin + i*(xmax-xmin)/pixelWidth\n            y = ymax - j*(ymax-ymin)/pixelHeight\n            if x < self.domain[0] or x > self.domain[1]:\n                possibleDict[(i,j)] += self.weight\n            elif abs(self.f(x)-y) < yCloseness:\n                possibleDict[(i,j)] += self.weight\n        \n    def grade(self, graphData):\n        mini, maxi = self.domain\n        if mini < graphData.xmin: mini = graphData.xmin\n        if maxi > graphData.xmax: maxi = graphData.xmax\n        pixelMin = graphData.indexFromXY(mini, 5)[0]\n        pixelMax = graphData.indexFromXY(maxi, 5)[0]\n        xPixelStep = float(graphData.xmax-graphData.xmin)/graphData.pixelWidth\n        pixelAnswerI = {}\n        pixelAnswerJ = {}\n    \n        for i in xrange(pixelMin, pixelMax+1):\n            x = graphData.xyFromIndex(i,0)[0]\n            y = self.f(x)\n            ii, j = graphData.indexFromXY(x, y)\n            # ii should be the same as i\n            pixelAnswerI[ii] = util.Point(ii, j)\n            pixelAnswerJ[j] = util.Point(ii, j)\n        counter = 0\n        bad = []\n        loopCounter = 0\n        for p in graphData.getGaussFunctionList():\n            if p.x > mini and p.x < maxi:\n                loopCounter += 1\n                i, j = graphData.indexFromXY(p.x, p.y)\n                if i in pixelAnswerI and abs(pixelAnswerI[i].y - j) < self.pixelCloseness:\n                    continue\n                elif j in pixelAnswerJ and abs(pixelAnswerJ[j].x - i) < self.pixelCloseness:\n                    continue\n                else:\n                    bad.append((p.x,p.y))\n                    counter += 1\n        numPixelsInDom = pixelMax-pixelMin\n        if counter > numPixelsInDom*(1-self.fraction):\n            return (0., self.failMessage)\n        else:\n            return (1., counter)\n\n    def requiredPolygons(self, otherVars):\n        (xmin, xmax, ymin, ymax, pixelWidth, pixelHeight) = self.unpackOtherVars(otherVars)\n        allPolys = []\n        highEdge = []\n        lowEdge = []\n        imin = int(max(0, (self.domain[0] - xmin)/float(xmax-xmin)*pixelWidth))\n        imax = int(min(pixelWidth, (self.domain[1] - xmin)/float(xmax-xmin)*pixelWidth))\n        for i in range(imin-self.pixelCloseness,imax+self.pixelCloseness):\n            x = xmin + i*(xmax-xmin)/pixelWidth\n            xprev = xmin + (i-1)*(xmax-xmin)/pixelWidth\n            y = self.f(x)\n            yprev = self.f(xprev)\n            j = (ymax - y)/float(ymax-ymin)*pixelHeight\n            jprev = (ymax-yprev)/float(ymax-ymin)*pixelHeight\n            perpSlope = (-float(j-jprev), 1.)\n            mag = (perpSlope[0]**2 + perpSlope[1]**2)**.5\n            highi = round(i + perpSlope[0]*self.pixelCloseness/mag)\n            highj = round(j + perpSlope[1]*self.pixelCloseness/mag)\n            lowi = round(i - perpSlope[0]*self.pixelCloseness/mag)\n            lowj = round(j - perpSlope[1]*self.pixelCloseness/mag)\n            # add to edges if possible\n            if (highj > 0 or lowj < pixelHeight):\n                if highi >= imin and highi <= imax and highj > 0:\n                    highEdge.append((highi,max(0,min(highj, pixelHeight))))\n                if lowi >= imin and lowi <= imax and lowj < pixelHeight:\n                    lowEdge.append((lowi,min(pixelHeight,max(lowj,0))))\n            elif len(highEdge) > 0:\n                highEdge.reverse()\n                highEdge.extend(lowEdge)\n                allPolys.append(highEdge)\n                highEdge = []\n                lowEdge = []\n\n        if len(highEdge) > 0: \n            highEdge.reverse()\n            highEdge.extend(lowEdge)\n            allPolys.append(highEdge)\n        return allPolys\n\n    def forbiddenPolygons(self, otherVars):\n        (xmin, xmax, ymin, ymax, pixelWidth, pixelHeight) = self.unpackOtherVars(otherVars)\n        allPolys = []\n        topPoly = []\n        bottomPoly = []\n        imin = int(max(0, (self.domain[0] - xmin)/float(xmax-xmin)*pixelWidth))\n        imax = int(min(pixelWidth, (self.domain[1] - xmin)/float(xmax-xmin)*pixelWidth))\n        def finishPoly(l, edge):\n            first = l[0]\n            last = l[-1]\n            l.append((last[0],edge))\n            l.append((first[0],edge))\n        for i in range(imin-self.pixelCloseness,imax+self.pixelCloseness):\n            x = xmin + i*(xmax-xmin)/pixelWidth\n            xprev = xmin + (i-1)*(xmax-xmin)/pixelWidth\n            y = self.f(x)\n            yprev = self.f(xprev)\n            j = (ymax - y)/float(ymax-ymin)*pixelHeight\n            jprev = (ymax-yprev)/float(ymax-ymin)*pixelHeight\n            perpSlope = (-float(j-jprev), 1.)\n            mag = (perpSlope[0]**2 + perpSlope[1]**2)**.5\n            highi = round(i + perpSlope[0]*self.pixelCloseness/mag)\n            highj = round(j + perpSlope[1]*self.pixelCloseness/mag)\n            lowi = round(i - perpSlope[0]*self.pixelCloseness/mag)\n            lowj = round(j - perpSlope[1]*self.pixelCloseness/mag)\n            # top\n            if (lowi >= imin and lowi <= imax and lowj > 0):\n                topPoly.append((lowi,min(lowj,pixelHeight)))\n            elif len(topPoly) > 0:\n                finishPoly(topPoly, 0)\n                allPolys.append(topPoly)\n                topPoly = []\n            # bottom\n            if (highi >= imin and highi <= imax and highj < pixelHeight):\n                bottomPoly.append((highi,max(highj, 0)))\n            elif len(bottomPoly) > 0:\n                finishPoly(bottomPoly, pixelHeight)\n                allPolys.append(bottomPoly)\n                bottomPoly = []\n        if len(topPoly) > 0: \n            finishPoly(topPoly, 0)\n            allPolys.append(topPoly)\n        if len(bottomPoly) > 0: \n            finishPoly(bottomPoly, pixelHeight)\n            allPolys.append(bottomPoly)\n        return allPolys\n\n\n    def requiredList(self, otherVars):\n        yCloseness = float(self.pixelCloseness)/(otherVars[\'pixelHeight\']/(otherVars[\'ymax\'] - otherVars[\'ymin\']))\n        def acceptRequired(x,y):\n            if x < self.domain[0] or x > self.domain[1]:\n                return False\n            return abs(self.f(x)-y) < yCloseness\n        return self.filteredList(otherVars, acceptRequired)\n    def forbiddenList(self, otherVars):\n        yCloseness = float(self.pixelCloseness)/(otherVars[\'pixelHeight\']/(otherVars[\'ymax\'] - otherVars[\'ymin\']))\n        def acceptForbidden(x,y):\n            if x < self.domain[0] or x > self.domain[1]:\n                return False\n            return abs(self.f(x)-y) > yCloseness\n        return self.filteredList(otherVars, acceptForbidden)\n",
"IsFunctionCriteria": "class IsFunctionCriteria(Criteria):\n    title = \"Graph is a Function Check\"\n    failMessage = \"Your graph needs to be a function (one y value per x value)\"\n    args = Criteria.args + [InputArg(\'domain\', \"Domain\", \"What range of x values the drawing needs to be a function in\", InputArg.DOMAIN,[-float(\'inf\'), float(\'inf\')]),\n                            InputArg(\'fraction\', \"Fraction of good\", \"What fraction of the points drawn need to follow the rule\", InputArg.FLOAT,.8)]\n    \'\'\'Check if graph is close to a function (one y value per x value)\n    Or at least that repeat y values are close to each other indicating a vertical line\'\'\'\n    def __init__(self, kwargs):\n        self.domain = (-float(\'inf\'), float(\'inf\'))\n        self.fraction = .95\n        Criteria.__init__(self, kwargs)\n\n    def grade(self, graphData):\n        mini, maxi = self.domain\n        if mini < graphData.xmin: mini = graphData.xmin\n        if maxi > graphData.xmax: maxi = graphData.xmax\n        iCount = [[] for i in range(graphData.pixelWidth)]\n        pixelMin = graphData.indexFromXY(mini, 5)[0]\n        pixelMax = graphData.indexFromXY(maxi, 5)[0]\n        for bp in graphData.blackPixels:\n            if bp.x > pixelMin and bp.x < pixelMax:\n                iCount[bp.x].append(bp.y)\n        total, illegal = 0, 0\n        for c in iCount:\n            if len(c) > 0: total += 1\n            c.sort()\n            for i in range(len(c)-1):\n                if abs(c[i+1] - c[i]) > 2: # if not vertically adjacent, it\'s illegal\n                    illegal += 1 \n        illegalFraction = -1 if total == 0 else float(illegal)/total\n        if illegalFraction > .05:\n            return (0., self.failMessage)\n        else:\n            return (1., None)\n"};
criteriaInputs = {"MonotonicCriteria": [{"displayName": "Grade Weight: ", "name": "weight", "default": 1, "required": false, "helpText": "What weight will this criteria have relative to others", "type": "float"}, {"displayName": "Fail Immediately: ", "name": "failFast", "default": false, "required": false, "helpText": "When True, a student who does not pass this criteria instantly gets 0% as a grade", "type": "boolean"}, {"displayName": "Domain", "name": "domain", "default": [-Infinity, Infinity], "required": false, "helpText": "What range of x values this criteria will be checked on", "type": "domain"}, {"displayName": "Trend", "name": "trend", "default": 0, "required": true, "helpText": "1 means monotonically increasing, -1 means decreasing, 0 means either way", "type": "integer"}, {"displayName": "Error margin (pixels)", "name": "pixelCloseness", "default": 10, "required": false, "helpText": "How far away in the wrong direction the student can go", "type": "integer"}], "PointsCriteria": [{"displayName": "Grade Weight: ", "name": "weight", "default": 1, "required": false, "helpText": "What weight will this criteria have relative to others", "type": "float"}, {"displayName": "Fail Immediately: ", "name": "failFast", "default": false, "required": false, "helpText": "When True, a student who does not pass this criteria instantly gets 0% as a grade", "type": "boolean"}, {"displayName": "Precision (pixels)", "name": "pixelCloseness", "default": 10, "required": false, "helpText": "How close the drawing has to get to the specified point to get full credit", "type": "integer"}, {"displayName": "Points", "name": "list", "default": [], "required": true, "helpText": "", "type": "multiplePoints"}], "DerivativeCriteria": [{"displayName": "Grade Weight: ", "name": "weight", "default": 1, "required": false, "helpText": "What weight will this criteria have relative to others", "type": "float"}, {"displayName": "Fail Immediately: ", "name": "failFast", "default": false, "required": false, "helpText": "When True, a student who does not pass this criteria instantly gets 0% as a grade", "type": "boolean"}, {"displayName": "Domain", "name": "domain", "default": [-Infinity, Infinity], "required": false, "helpText": "For what x values you want to apply the criteria", "type": "domain"}, {"displayName": "Fraction Good", "name": "fraction", "default": 0.8, "required": false, "helpText": "What fraction of points drawn need to be inside the appropriate region", "type": "float"}, {"displayName": "Function of slope", "name": "fprime", "default": "", "required": true, "helpText": "A function of the slope specified in terms of x specified with valid python syntax", "type": "function"}, {"displayName": "Angle margin (degrees)", "name": "angleCloseness", "default": 20, "required": false, "helpText": "How close the angle of the drawn slope has to be to the correct one", "type": "float"}], "Criteria": [{"displayName": "Grade Weight: ", "name": "weight", "default": 1, "required": false, "helpText": "What weight will this criteria have relative to others", "type": "float"}, {"displayName": "Fail Immediately: ", "name": "failFast", "default": false, "required": false, "helpText": "When True, a student who does not pass this criteria instantly gets 0% as a grade", "type": "boolean"}], "FunctionFollowedCriteria": [{"displayName": "Grade Weight: ", "name": "weight", "default": 1, "required": false, "helpText": "What weight will this criteria have relative to others", "type": "float"}, {"displayName": "Fail Immediately: ", "name": "failFast", "default": false, "required": false, "helpText": "When True, a student who does not pass this criteria instantly gets 0% as a grade", "type": "boolean"}, {"displayName": "Domain", "name": "domain", "default": [-Infinity, Infinity], "required": false, "helpText": "For what x values you want to apply the criteria", "type": "domain"}, {"displayName": "Fraction Good", "name": "fraction", "default": 0.8, "required": false, "helpText": "What fraction of points drawn need to be inside the appropriate region", "type": "float"}, {"displayName": "Function", "name": "f", "default": "", "required": true, "helpText": "A function in terms of x specified with valid Python syntax", "type": "function"}, {"displayName": "Error margin (pixels):", "name": "pixelCloseness", "default": 10, "required": false, "helpText": "How close the drawing has to be to the correct answer", "type": "integer"}], "IsFunctionCriteria": [{"displayName": "Grade Weight: ", "name": "weight", "default": 1, "required": false, "helpText": "What weight will this criteria have relative to others", "type": "float"}, {"displayName": "Fail Immediately: ", "name": "failFast", "default": false, "required": false, "helpText": "When True, a student who does not pass this criteria instantly gets 0% as a grade", "type": "boolean"}, {"displayName": "Domain", "name": "domain", "default": [-Infinity, Infinity], "required": false, "helpText": "What range of x values the drawing needs to be a function in", "type": "domain"}, {"displayName": "Fraction of good", "name": "fraction", "default": 0.8, "required": false, "helpText": "What fraction of the points drawn need to follow the rule", "type": "float"}]};
